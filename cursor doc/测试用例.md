# æµ‹è¯•è®¡åˆ’ä¸ç”¨ä¾‹æ–‡æ¡£

## ğŸ“‘ ç›®å½•
- [1. æµ‹è¯•ç­–ç•¥æ¦‚è§ˆ](#1-æµ‹è¯•ç­–ç•¥æ¦‚è§ˆ)
- [2. å•å…ƒæµ‹è¯•](#2-å•å…ƒæµ‹è¯•)
- [3. é›†æˆæµ‹è¯•](#3-é›†æˆæµ‹è¯•)
- [4. ç«¯åˆ°ç«¯æµ‹è¯•](#4-ç«¯åˆ°ç«¯æµ‹è¯•)
- [5. æ€§èƒ½æµ‹è¯•](#5-æ€§èƒ½æµ‹è¯•)
- [6. å®‰å…¨æµ‹è¯•](#6-å®‰å…¨æµ‹è¯•)
- [7. å¯ç”¨æ€§ä¸å®¹é”™æµ‹è¯•](#7-å¯ç”¨æ€§ä¸å®¹é”™æµ‹è¯•)
- [8. ç°åº¦ä¸å›æ»šæµ‹è¯•](#8-ç°åº¦ä¸å›æ»šæµ‹è¯•)
- [9. æµ‹è¯•è¦†ç›–ç‡è¦æ±‚](#9-æµ‹è¯•è¦†ç›–ç‡è¦æ±‚)

---

## 1. æµ‹è¯•ç­–ç•¥æ¦‚è§ˆ

### 1.1 æµ‹è¯•é‡‘å­—å¡”

```
        /\
       /  \
      / E2E \     < 10%
     /______\
    /        \
   /  é›†æˆæµ‹è¯• \   < 30%
  /______________\
 /                \
 /    å•å…ƒæµ‹è¯•     \   > 60%
 /__________________\
```

### 1.2 æµ‹è¯•ç›®æ ‡

| æµ‹è¯•ç±»å‹ | è¦†ç›–ç‡ç›®æ ‡ | é‡ç‚¹éªŒè¯ |
|---------|------------|----------|
| **å•å…ƒæµ‹è¯•** | > 80% | ä¸šåŠ¡é€»è¾‘æ­£ç¡®æ€§ |
| **é›†æˆæµ‹è¯•** | > 70% | æ¨¡å—é—´äº¤äº’ |
| **APIæµ‹è¯•** | 100% | æ¥å£å¥‘çº¦ |
| **E2Eæµ‹è¯•** | æ ¸å¿ƒæµç¨‹ | ç”¨æˆ·ä½“éªŒ |

---

## 2. å•å…ƒæµ‹è¯•

### 2.1 SaaSä¸»å¹³å°å•å…ƒæµ‹è¯•

#### ğŸ”§ Serviceå±‚æµ‹è¯•
```python
# tests/unit/services/test_tenant_service.py
import pytest
from unittest.mock import Mock, patch
from app.services.tenant_service import TenantService
from app.exceptions import TenantNotFoundError, DuplicateTenantError

class TestTenantService:
    @pytest.fixture
    def service(self):
        return TenantService()
    
    def test_create_tenant_success(self, service):
        """æµ‹è¯•åˆ›å»ºç§Ÿæˆ· - æˆåŠŸåœºæ™¯"""
        tenant_data = {
            "name": "Test Company",
            "email": "admin@test.com",
            "plan": "standard"
        }
        
        with patch.object(service.repository, 'create') as mock_create:
            mock_create.return_value = {"id": "tenant_123", **tenant_data}
            
            result = service.create_tenant(tenant_data)
            
            assert result["id"] == "tenant_123"
            assert result["name"] == tenant_data["name"]
            mock_create.assert_called_once()
    
    def test_create_tenant_duplicate_email(self, service):
        """æµ‹è¯•åˆ›å»ºç§Ÿæˆ· - é‚®ç®±é‡å¤åœºæ™¯"""
        tenant_data = {"email": "existing@test.com"}
        
        with patch.object(service.repository, 'get_by_email') as mock_get:
            mock_get.return_value = {"id": "existing_tenant"}
            
            with pytest.raises(DuplicateTenantError):
                service.create_tenant(tenant_data)
```

#### ğŸ’¬ Message Serviceæµ‹è¯•
```python
# tests/unit/services/test_message_service.py
class TestMessageService:
    def test_create_message_with_tenant_isolation(self, service):
        """æµ‹è¯•æ¶ˆæ¯åˆ›å»ºçš„ç§Ÿæˆ·éš”ç¦»"""
        message_data = {
            "content": "Hello",
            "session_id": "session_123",
            "user_id": "user_456"
        }
        tenant_id = "tenant_789"
        
        with patch.object(service, '_validate_session_belongs_to_tenant') as mock_validate:
            mock_validate.return_value = True
            
            result = service.create_message(message_data, tenant_id)
            
            assert result["tenant_id"] == tenant_id
            mock_validate.assert_called_once_with("session_123", tenant_id)
    
    def test_get_messages_filters_by_tenant(self, service):
        """æµ‹è¯•æ¶ˆæ¯æŸ¥è¯¢çš„ç§Ÿæˆ·è¿‡æ»¤"""
        session_id = "session_123"
        tenant_id = "tenant_789"
        
        with patch.object(service.repository, 'get_by_session') as mock_get:
            mock_get.return_value = [
                {"id": "msg_1", "tenant_id": tenant_id},
                {"id": "msg_2", "tenant_id": tenant_id}
            ]
            
            result = service.get_session_messages(session_id, tenant_id)
            
            assert len(result) == 2
            assert all(msg["tenant_id"] == tenant_id for msg in result)
```

#### ğŸ” Authenticationæµ‹è¯•
```python
# tests/unit/auth/test_jwt_service.py
class TestJWTService:
    def test_generate_token_includes_tenant_id(self, jwt_service):
        """æµ‹è¯•JWTç”ŸæˆåŒ…å«ç§Ÿæˆ·ID"""
        user_data = {
            "user_id": "user_123",
            "tenant_id": "tenant_456",
            "role": "staff"
        }
        
        token = jwt_service.generate_token(user_data)
        decoded = jwt_service.decode_token(token)
        
        assert decoded["tenant_id"] == user_data["tenant_id"]
        assert decoded["user_id"] == user_data["user_id"]
        assert decoded["role"] == user_data["role"]
    
    def test_decode_expired_token_raises_exception(self, jwt_service):
        """æµ‹è¯•è§£ç è¿‡æœŸTokenæŠ›å‡ºå¼‚å¸¸"""
        with patch('time.time', return_value=time.time() + 3700):  # 1å°æ—¶å
            with pytest.raises(TokenExpiredError):
                jwt_service.decode_token("expired_token")
```

### 2.2 å‰ç«¯ç»„ä»¶å•å…ƒæµ‹è¯•

#### ğŸ¨ Vueç»„ä»¶æµ‹è¯•
```typescript
// tests/unit/components/MessageInput.test.ts
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import MessageInput from '@/components/MessageInput.vue'

describe('MessageInput', () => {
  it('emits send event with message content', async () => {
    const wrapper = mount(MessageInput)
    const input = wrapper.find('input[type="text"]')
    const sendButton = wrapper.find('[data-testid="send-button"]')
    
    await input.setValue('Hello world')
    await sendButton.trigger('click')
    
    expect(wrapper.emitted('send')).toHaveLength(1)
    expect(wrapper.emitted('send')?.[0]).toEqual(['Hello world'])
  })
  
  it('clears input after sending message', async () => {
    const wrapper = mount(MessageInput)
    const input = wrapper.find('input[type="text"]')
    
    await input.setValue('Test message')
    await wrapper.find('[data-testid="send-button"]').trigger('click')
    
    expect((input.element as HTMLInputElement).value).toBe('')
  })
  
  it('disables send button when input is empty', () => {
    const wrapper = mount(MessageInput)
    const sendButton = wrapper.find('[data-testid="send-button"]')
    
    expect(sendButton.attributes('disabled')).toBeDefined()
  })
})
```

### 2.3 AstrBotå®ä¾‹å•å…ƒæµ‹è¯•

#### ğŸ¤– æ¶ˆæ¯å¤„ç†é€»è¾‘æµ‹è¯•
```python
# tests/unit/astrbot/test_message_processor.py
class TestMessageProcessor:
    def test_blacklist_check_blocks_user(self, processor):
        """æµ‹è¯•é»‘åå•æ£€æŸ¥æ‹¦æˆªç”¨æˆ·æ¶ˆæ¯"""
        message = {
            "user_id": "blocked_user",
            "platform": "wechat",
            "content": "Hello"
        }
        
        with patch.object(processor.blacklist_cache, 'is_blocked') as mock_check:
            mock_check.return_value = True
            
            result = processor.process_message(message)
            
            assert result["action"] == "blocked"
            assert result["reason"] == "blacklist"
    
    def test_voice_message_triggers_asr(self, processor):
        """æµ‹è¯•è¯­éŸ³æ¶ˆæ¯è§¦å‘ASRå¤„ç†"""
        voice_message = {
            "type": "voice",
            "content": "voice_file_url",
            "user_id": "user_123"
        }
        
        with patch.object(processor.asr_service, 'process_async') as mock_asr:
            result = processor.process_message(voice_message)
            
            assert result["action"] == "asr_processing"
            mock_asr.assert_called_once()
```

---

## 3. é›†æˆæµ‹è¯•

### 3.1 APIå¥‘çº¦æµ‹è¯•

#### ğŸ“¡ SaaSä¸»å¹³å°APIæµ‹è¯•
```python
# tests/integration/test_message_api.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

@pytest.fixture
def authenticated_client():
    client = TestClient(app)
    # è®¾ç½®è®¤è¯token
    token = generate_test_token(tenant_id="test_tenant")
    client.headers.update({"Authorization": f"Bearer {token}"})
    return client

class TestMessageAPI:
    def test_create_message_success(self, authenticated_client):
        """æµ‹è¯•åˆ›å»ºæ¶ˆæ¯API - æˆåŠŸåœºæ™¯"""
        payload = {
            "content": "Hello, World!",
            "type": "text",
            "session_id": "session_123"
        }
        
        response = authenticated_client.post("/api/v1/messages", json=payload)
        
        assert response.status_code == 201
        data = response.json()
        assert data["success"] is True
        assert data["data"]["content"] == payload["content"]
        assert "id" in data["data"]
        assert "timestamp" in data["data"]
    
    def test_get_messages_filters_by_tenant(self, authenticated_client):
        """æµ‹è¯•è·å–æ¶ˆæ¯APIçš„ç§Ÿæˆ·è¿‡æ»¤"""
        session_id = "session_123"
        
        response = authenticated_client.get(f"/api/v1/sessions/{session_id}/messages")
        
        assert response.status_code == 200
        data = response.json()
        # éªŒè¯æ‰€æœ‰è¿”å›çš„æ¶ˆæ¯éƒ½å±äºå½“å‰ç§Ÿæˆ·
        for message in data["data"]:
            assert message["tenant_id"] == "test_tenant"
    
    def test_create_message_cross_tenant_blocked(self, authenticated_client):
        """æµ‹è¯•è·¨ç§Ÿæˆ·åˆ›å»ºæ¶ˆæ¯è¢«é˜»æ­¢"""
        payload = {
            "content": "Unauthorized message",
            "type": "text",
            "session_id": "other_tenant_session"  # å±äºå…¶ä»–ç§Ÿæˆ·çš„session
        }
        
        response = authenticated_client.post("/api/v1/messages", json=payload)
        
        assert response.status_code == 403
        assert "æ— æƒé™" in response.json()["error"]["message"]
```

### 3.2 æ ¸å¿ƒæ¶ˆæ¯æµæµ‹è¯•

#### ğŸ”„ ç”¨æˆ·æ¶ˆæ¯ä¸Šè¡Œå®Œæ•´é“¾è·¯æµ‹è¯•
```python
# tests/integration/test_message_flow.py
class TestMessageFlow:
    @pytest.mark.asyncio
    async def test_user_message_upward_flow(self):
        """æµ‹è¯•ç”¨æˆ·æ¶ˆæ¯ä¸Šè¡Œå®Œæ•´æµç¨‹"""
        # 1. æ¨¡æ‹ŸIMå¹³å°å‘é€æ¶ˆæ¯åˆ°AstrBot
        im_message = {
            "user_id": "user_123",
            "platform": "wechat",
            "content": "æˆ‘éœ€è¦å¸®åŠ©",
            "message_type": "text"
        }
        
        # 2. AstrBotå¤„ç†æ¶ˆæ¯
        with patch('astrbot.webhook_reporter.report') as mock_webhook:
            astrbot_result = await astrbot_instance.process_message(im_message)
            
            # éªŒè¯AstrBotå¤„ç†æˆåŠŸ
            assert astrbot_result["status"] == "processed"
            
            # éªŒè¯Webhookä¸ŠæŠ¥è¢«è°ƒç”¨
            mock_webhook.assert_called_once()
            webhook_payload = mock_webhook.call_args[0][0]
            assert webhook_payload["content"] == im_message["content"]
        
        # 3. SaaSå¹³å°æ¥æ”¶Webhook
        webhook_response = await saas_platform.handle_webhook(webhook_payload)
        assert webhook_response["status"] == "success"
        
        # 4. éªŒè¯æ¶ˆæ¯å­˜å‚¨åˆ°æ•°æ®åº“
        stored_message = await db.get_message_by_id(webhook_payload["message_id"])
        assert stored_message is not None
        assert stored_message["content"] == im_message["content"]
        
        # 5. éªŒè¯WebSocketæ¨é€ç»™å®¢æœ
        websocket_events = await websocket_mock.get_events()
        assert len(websocket_events) == 1
        assert websocket_events[0]["type"] == "new_message"
```

#### ğŸ“ è¯­éŸ³æ¶ˆæ¯ASRå¤„ç†æµ‹è¯•
```python
class TestVoiceMessageFlow:
    @pytest.mark.asyncio
    async def test_voice_message_asr_processing(self):
        """æµ‹è¯•è¯­éŸ³æ¶ˆæ¯ASRå¤„ç†å®Œæ•´æµç¨‹"""
        voice_message = {
            "user_id": "user_123",
            "platform": "wechat",
            "content": "voice_file_url",
            "message_type": "voice"
        }
        
        # 1. æ¨¡æ‹Ÿè¯­éŸ³æ¶ˆæ¯å¤„ç†
        with patch('astrbot.storage.upload_file') as mock_upload:
            with patch('astrbot.asr_service.process') as mock_asr:
                mock_upload.return_value = "signed_url"
                mock_asr.return_value = {
                    "text": "ä½ å¥½ï¼Œæˆ‘éœ€è¦å¸®åŠ©",
                    "confidence": 0.95
                }
                
                result = await astrbot_instance.process_voice_message(voice_message)
                
                # éªŒè¯æ–‡ä»¶ä¸Šä¼ 
                mock_upload.assert_called_once()
                
                # éªŒè¯ASRè°ƒç”¨
                mock_asr.assert_called_once()
                
                # éªŒè¯ç»“æœä¸ŠæŠ¥
                assert result["asr_result"]["text"] == "ä½ å¥½ï¼Œæˆ‘éœ€è¦å¸®åŠ©"
```

### 3.3 é»‘åå•åŠŸèƒ½æµ‹è¯•

#### ğŸ›¡ï¸ é»‘åå•åŒæ­¥å’Œæ‹¦æˆªæµ‹è¯•
```python
class TestBlacklistFlow:
    def test_blacklist_sync_and_blocking(self):
        """æµ‹è¯•é»‘åå•åŒæ­¥å’Œæ‹¦æˆªåŠŸèƒ½"""
        # 1. åœ¨SaaSå¹³å°æ·»åŠ é»‘åå•
        blacklist_entry = {
            "user_id": "spam_user",
            "platform": "wechat",
            "reason": "æ¶æ„ç”¨æˆ·",
            "tenant_id": "test_tenant"
        }
        
        saas_response = saas_client.post("/api/v1/blacklist", json=blacklist_entry)
        assert saas_response.status_code == 201
        
        # 2. éªŒè¯AstrBotå®ä¾‹æ”¶åˆ°åŒæ­¥æ¨é€
        with patch('astrbot.blacklist_cache.add_user') as mock_add:
            # æ¨¡æ‹Ÿé…ç½®æ¨é€
            config_update = {
                "config_type": "blacklist",
                "action": "add",
                "data": blacklist_entry
            }
            
            astrbot_response = astrbot_client.post("/config/update", json=config_update)
            assert astrbot_response.status_code == 200
            mock_add.assert_called_once_with("spam_user", "wechat")
        
        # 3. éªŒè¯é»‘åå•ç”¨æˆ·æ¶ˆæ¯è¢«æ‹¦æˆª
        blocked_message = {
            "user_id": "spam_user",
            "platform": "wechat",
            "content": "spam content"
        }
        
        with patch('astrbot.webhook_reporter.report') as mock_webhook:
            result = astrbot_instance.process_message(blocked_message)
            
            assert result["action"] == "blocked"
            # éªŒè¯æ‹¦æˆªäº‹ä»¶ä¸ŠæŠ¥
            mock_webhook.assert_called_once()
            webhook_payload = mock_webhook.call_args[0][0]
            assert webhook_payload["message_status"] == "blocked_by_blacklist"
```

---

## 4. ç«¯åˆ°ç«¯æµ‹è¯•

### 4.1 å®¢æœå·¥ä½œå°E2Eæµ‹è¯•

#### ğŸ­ å®¢æœæ¥å¾…æµç¨‹æµ‹è¯•
```typescript
// tests/e2e/customer-service-workflow.spec.ts
import { test, expect } from '@playwright/test'

test.describe('å®¢æœå·¥ä½œå°å®Œæ•´æµç¨‹', () => {
  test.beforeEach(async ({ page }) => {
    // ç™»å½•å®¢æœç³»ç»Ÿ
    await page.goto('/login')
    await page.fill('[data-testid="email"]', 'staff@example.com')
    await page.fill('[data-testid="password"]', 'password123')
    await page.click('[data-testid="login-button"]')
    await expect(page).toHaveURL('/dashboard')
  })

  test('å®Œæ•´çš„å®¢æœæ¥å¾…æµç¨‹', async ({ page }) => {
    // 1. ç­‰å¾…æ–°æ¶ˆæ¯é€šçŸ¥
    await page.waitForSelector('[data-testid="new-message-notification"]')
    
    // 2. æŸ¥çœ‹æ¶ˆæ¯åˆ—è¡¨
    const sessionList = page.locator('[data-testid="session-list"]')
    await expect(sessionList).toBeVisible()
    
    // 3. ç‚¹å‡»ç¬¬ä¸€ä¸ªä¼šè¯
    await page.click('[data-testid="session-item"]:first-child')
    
    // 4. éªŒè¯ä¼šè¯è¯¦æƒ…åŠ è½½
    const messageArea = page.locator('[data-testid="message-area"]')
    await expect(messageArea).toBeVisible()
    
    // 5. æŸ¥çœ‹ç”¨æˆ·æ¶ˆæ¯
    const userMessage = page.locator('[data-testid="user-message"]').first()
    await expect(userMessage).toContainText('ç”¨æˆ·é—®é¢˜')
    
    // 6. ä½¿ç”¨æ™ºèƒ½å›å¤å»ºè®®
    const smartReply = page.locator('[data-testid="smart-reply-suggestion"]').first()
    if (await smartReply.isVisible()) {
      await smartReply.click()
    }
    
    // 7. ç¼–è¾‘å¹¶å‘é€å›å¤
    const replyInput = page.locator('[data-testid="reply-input"]')
    await replyInput.fill('æ„Ÿè°¢æ‚¨çš„å’¨è¯¢ï¼Œæˆ‘æ¥ä¸ºæ‚¨è¯¦ç»†è§£ç­”...')
    await page.click('[data-testid="send-button"]')
    
    // 8. éªŒè¯æ¶ˆæ¯å‘é€æˆåŠŸ
    await expect(page.locator('[data-testid="message-sent-indicator"]')).toBeVisible()
    
    // 9. éªŒè¯æ¶ˆæ¯æ˜¾ç¤ºåœ¨å¯¹è¯ä¸­
    const staffMessage = page.locator('[data-testid="staff-message"]').last()
    await expect(staffMessage).toContainText('æ„Ÿè°¢æ‚¨çš„å’¨è¯¢')
    
    // 10. ç»“æŸä¼šè¯
    await page.click('[data-testid="end-session-button"]')
    await page.click('[data-testid="confirm-end-session"]')
    
    // 11. éªŒè¯ä¼šè¯çŠ¶æ€æ›´æ–°
    await expect(page.locator('[data-testid="session-status"]')).toContainText('å·²ç»“æŸ')
  })

  test('è¯­éŸ³æ¶ˆæ¯å¤„ç†æµç¨‹', async ({ page }) => {
    // é€‰æ‹©åŒ…å«è¯­éŸ³æ¶ˆæ¯çš„ä¼šè¯
    await page.click('[data-testid="session-with-voice"]')
    
    // ç­‰å¾…è¯­éŸ³æ¶ˆæ¯åŠ è½½
    const voiceMessage = page.locator('[data-testid="voice-message"]')
    await expect(voiceMessage).toBeVisible()
    
    // ç‚¹å‡»æ’­æ”¾è¯­éŸ³
    await page.click('[data-testid="play-voice-button"]')
    
    // éªŒè¯ASRè½¬å†™ç»“æœæ˜¾ç¤º
    const asrResult = page.locator('[data-testid="asr-text"]')
    await expect(asrResult).toBeVisible()
    await expect(asrResult).toContainText('è½¬å†™ç»“æœ')
    
    // åŸºäºè½¬å†™ç»“æœå›å¤
    await page.fill('[data-testid="reply-input"]', 'æ ¹æ®æ‚¨çš„è¯­éŸ³æè¿°ï¼Œå»ºè®®æ‚¨...')
    await page.click('[data-testid="send-button"]')
  })

  test('ä¼šè¯è½¬æ¥æµç¨‹', async ({ page }) => {
    // æ‰“å¼€ä¼šè¯
    await page.click('[data-testid="session-item"]:first-child')
    
    // å‘èµ·è½¬æ¥
    await page.click('[data-testid="transfer-button"]')
    
    // é€‰æ‹©è½¬æ¥ç›®æ ‡å®¢æœ
    await page.selectOption('[data-testid="transfer-target"]', 'staff-2@example.com')
    await page.fill('[data-testid="transfer-note"]', 'ç”¨æˆ·é—®é¢˜è¾ƒå¤æ‚ï¼Œéœ€è¦ä¸“å®¶å¤„ç†')
    await page.click('[data-testid="confirm-transfer"]')
    
    // éªŒè¯è½¬æ¥æˆåŠŸ
    await expect(page.locator('[data-testid="transfer-success-message"]')).toBeVisible()
    
    // éªŒè¯ä¼šè¯çŠ¶æ€å˜æ›´
    await expect(page.locator('[data-testid="session-status"]')).toContainText('å·²è½¬æ¥')
  })
})
```

### 4.2 ç®¡ç†åå°E2Eæµ‹è¯•

#### ğŸ‘¨â€ğŸ’¼ ç§Ÿæˆ·ç®¡ç†æµç¨‹æµ‹è¯•
```typescript
// tests/e2e/admin-panel.spec.ts
test.describe('ç®¡ç†åå°åŠŸèƒ½', () => {
  test('ç§Ÿæˆ·åˆ›å»ºå’Œé…ç½®æµç¨‹', async ({ page }) => {
    // ç®¡ç†å‘˜ç™»å½•
    await page.goto('/admin/login')
    await page.fill('[data-testid="admin-email"]', 'admin@example.com')
    await page.fill('[data-testid="admin-password"]', 'admin123')
    await page.click('[data-testid="admin-login-button"]')
    
    // åˆ›å»ºæ–°ç§Ÿæˆ·
    await page.click('[data-testid="create-tenant-button"]')
    await page.fill('[data-testid="tenant-name"]', 'æµ‹è¯•ä¼ä¸š')
    await page.fill('[data-testid="tenant-email"]', 'test@company.com')
    await page.selectOption('[data-testid="tenant-plan"]', 'standard')
    await page.click('[data-testid="submit-tenant"]')
    
    // éªŒè¯ç§Ÿæˆ·åˆ›å»ºæˆåŠŸ
    await expect(page.locator('[data-testid="tenant-created-message"]')).toBeVisible()
    
    // é…ç½®ç§Ÿæˆ·AstrBotå®ä¾‹
    await page.click('[data-testid="configure-instance-button"]')
    await page.fill('[data-testid="wechat-app-id"]', 'wx123456789')
    await page.fill('[data-testid="wechat-secret"]', 'secret123')
    await page.fill('[data-testid="llm-api-key"]', 'sk-xxxxxxxxx')
    await page.click('[data-testid="save-config"]')
    
    // éªŒè¯å®ä¾‹éƒ¨ç½²çŠ¶æ€
    await expect(page.locator('[data-testid="instance-status"]')).toContainText('è¿è¡Œä¸­')
  })
})
```

---

## 5. æ€§èƒ½æµ‹è¯•

### 5.1 æ¶ˆæ¯å¹¶å‘å¤„ç†æµ‹è¯•

#### âš¡ é«˜å¹¶å‘æ¶ˆæ¯å¤„ç†
```python
# tests/performance/test_message_concurrency.py
import asyncio
import aiohttp
import time
from concurrent.futures import ThreadPoolExecutor

class TestMessageConcurrency:
    async def test_concurrent_message_processing(self):
        """æµ‹è¯•æ¶ˆæ¯å¹¶å‘å¤„ç†èƒ½åŠ›"""
        concurrent_users = 100
        messages_per_user = 10
        
        async def send_message(session, user_id):
            payload = {
                "content": f"æ¶ˆæ¯æ¥è‡ªç”¨æˆ·{user_id}",
                "type": "text",
                "session_id": f"session_{user_id}"
            }
            
            start_time = time.time()
            async with session.post("/api/v1/messages", json=payload) as response:
                end_time = time.time()
                return {
                    "status_code": response.status,
                    "response_time": end_time - start_time,
                    "user_id": user_id
                }
        
        async with aiohttp.ClientSession() as session:
            tasks = []
            for user_id in range(concurrent_users):
                for _ in range(messages_per_user):
                    task = send_message(session, user_id)
                    tasks.append(task)
            
            start_time = time.time()
            results = await asyncio.gather(*tasks)
            end_time = time.time()
            
            # æ€§èƒ½æŒ‡æ ‡éªŒè¯
            total_requests = len(results)
            successful_requests = sum(1 for r in results if r["status_code"] == 201)
            avg_response_time = sum(r["response_time"] for r in results) / total_requests
            throughput = total_requests / (end_time - start_time)
            
            # æ–­è¨€æ€§èƒ½è¦æ±‚
            assert successful_requests / total_requests > 0.95  # æˆåŠŸç‡ > 95%
            assert avg_response_time < 0.2  # å¹³å‡å“åº”æ—¶é—´ < 200ms
            assert throughput > 500  # ååé‡ > 500 TPS
```

### 5.2 æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½æµ‹è¯•

#### ğŸ—„ï¸ å¤§æ•°æ®é‡æŸ¥è¯¢æµ‹è¯•
```python
class TestDatabasePerformance:
    def test_message_search_performance(self):
        """æµ‹è¯•æ¶ˆæ¯æœç´¢æŸ¥è¯¢æ€§èƒ½"""
        # å‡†å¤‡æµ‹è¯•æ•°æ®ï¼ˆ10ä¸‡æ¡æ¶ˆæ¯ï¼‰
        self.setup_large_dataset(100000)
        
        # æµ‹è¯•å„ç§æŸ¥è¯¢åœºæ™¯
        test_cases = [
            {"type": "keyword_search", "keyword": "å¸®åŠ©"},
            {"type": "date_range", "start_date": "2024-01-01", "end_date": "2024-01-31"},
            {"type": "user_filter", "user_id": "user_12345"},
            {"type": "complex_query", "keyword": "é—®é¢˜", "date_range": True}
        ]
        
        for case in test_cases:
            start_time = time.time()
            results = self.execute_search_query(case)
            end_time = time.time()
            
            query_time = end_time - start_time
            
            # æŸ¥è¯¢æ€§èƒ½è¦æ±‚
            assert query_time < 0.1  # æŸ¥è¯¢æ—¶é—´ < 100ms
            assert len(results) > 0  # æœ‰ç»“æœè¿”å›
            
            # éªŒè¯ç»“æœæ­£ç¡®æ€§
            if case["type"] == "keyword_search":
                assert all(case["keyword"] in r["content"] for r in results)
```

---

## 6. å®‰å…¨æµ‹è¯•

### 6.1 æƒé™ç»•è¿‡æµ‹è¯•

#### ğŸ”’ å¤šç§Ÿæˆ·å®‰å…¨æµ‹è¯•
```python
# tests/security/test_tenant_isolation.py
class TestTenantSecurity:
    def test_cross_tenant_data_access_blocked(self):
        """æµ‹è¯•è·¨ç§Ÿæˆ·æ•°æ®è®¿é—®è¢«é˜»æ­¢"""
        # ç§Ÿæˆ·Açš„token
        tenant_a_token = generate_test_token(tenant_id="tenant_a")
        # ç§Ÿæˆ·Bçš„èµ„æºID
        tenant_b_session_id = "session_belongs_to_tenant_b"
        
        response = client.get(
            f"/api/v1/sessions/{tenant_b_session_id}/messages",
            headers={"Authorization": f"Bearer {tenant_a_token}"}
        )
        
        assert response.status_code == 403
        assert "æ— æƒé™" in response.json()["error"]["message"]
    
    def test_sql_injection_protection(self):
        """æµ‹è¯•SQLæ³¨å…¥é˜²æŠ¤"""
        malicious_payloads = [
            "'; DROP TABLE messages; --",
            "1' OR '1'='1",
            "admin'/**/OR/**/1=1#"
        ]
        
        for payload in malicious_payloads:
            response = client.get(f"/api/v1/messages?search={payload}")
            
            # åº”è¯¥è¿”å›æ­£å¸¸å“åº”ï¼Œè€Œä¸æ˜¯æ•°æ®åº“é”™è¯¯
            assert response.status_code in [200, 400]
            assert "database error" not in response.text.lower()
    
    def test_xss_protection(self):
        """æµ‹è¯•XSSæ”»å‡»é˜²æŠ¤"""
        xss_payload = "<script>alert('XSS')</script>"
        
        response = client.post("/api/v1/messages", json={
            "content": xss_payload,
            "type": "text",
            "session_id": "session_123"
        })
        
        assert response.status_code == 201
        message = response.json()["data"]
        
        # éªŒè¯å†…å®¹è¢«æ­£ç¡®è½¬ä¹‰
        assert "<script>" not in message["content"]
        assert "&lt;script&gt;" in message["content"] or message["content"] != xss_payload
```

### 6.2 è®¤è¯æˆæƒæµ‹è¯•

#### ğŸ”‘ Tokenå®‰å…¨æµ‹è¯•
```python
class TestAuthSecurity:
    def test_expired_token_rejected(self):
        """æµ‹è¯•è¿‡æœŸTokenè¢«æ‹’ç»"""
        expired_token = generate_expired_token()
        
        response = client.get(
            "/api/v1/messages",
            headers={"Authorization": f"Bearer {expired_token}"}
        )
        
        assert response.status_code == 401
        assert "token expired" in response.json()["error"]["message"].lower()
    
    def test_invalid_token_rejected(self):
        """æµ‹è¯•æ— æ•ˆTokenè¢«æ‹’ç»"""
        invalid_tokens = [
            "invalid_token",
            "",
            "Bearer ",
            "malformed.jwt.token"
        ]
        
        for token in invalid_tokens:
            response = client.get(
                "/api/v1/messages",
                headers={"Authorization": f"Bearer {token}"}
            )
            
            assert response.status_code == 401
```

---

## 7. å¯ç”¨æ€§ä¸å®¹é”™æµ‹è¯•

### 7.1 æœåŠ¡æ•…éšœæµ‹è¯•

#### ğŸš¨ AstrBotå®ä¾‹æ•…éšœæµ‹è¯•
```python
class TestServiceFailure:
    def test_astrbot_instance_failure_handling(self):
        """æµ‹è¯•AstrBotå®ä¾‹æ•…éšœå¤„ç†"""
        # 1. æ¨¡æ‹ŸAstrBotå®ä¾‹ä¸å¯ç”¨
        with patch('astrbot_client.health_check') as mock_health:
            mock_health.side_effect = ConnectionError("Instance unreachable")
            
            # 2. SaaSå¹³å°åº”è¯¥æ£€æµ‹åˆ°æ•…éšœ
            health_status = saas_platform.check_instance_health("tenant_123")
            assert health_status["status"] == "unhealthy"
            
            # 3. éªŒè¯å‘Šè­¦è¢«è§¦å‘
            alerts = monitoring_system.get_alerts()
            assert any("AstrBot instance down" in alert["message"] for alert in alerts)
            
            # 4. éªŒè¯å®ä¾‹é‡å¯è¢«è§¦å‘
            with patch('kubernetes_client.restart_pod') as mock_restart:
                saas_platform.handle_instance_failure("tenant_123")
                mock_restart.assert_called_once()
    
    def test_database_connection_failure(self):
        """æµ‹è¯•æ•°æ®åº“è¿æ¥æ•…éšœå¤„ç†"""
        with patch('database.connection.execute') as mock_db:
            mock_db.side_effect = ConnectionError("Database unreachable")
            
            response = client.get("/api/v1/messages")
            
            # åº”è¯¥è¿”å›æœåŠ¡ä¸å¯ç”¨ï¼Œè€Œä¸æ˜¯å´©æºƒ
            assert response.status_code == 503
            assert "æœåŠ¡æš‚æ—¶ä¸å¯ç”¨" in response.json()["error"]["message"]
```

### 7.2 é™çº§æœåŠ¡æµ‹è¯•

#### ğŸ“‰ æœåŠ¡é™çº§æµ‹è¯•
```python
class TestServiceDegradation:
    def test_llm_service_unavailable_fallback(self):
        """æµ‹è¯•LLMæœåŠ¡ä¸å¯ç”¨æ—¶çš„é™çº§å¤„ç†"""
        with patch('llm_service.infer') as mock_llm:
            mock_llm.side_effect = TimeoutError("LLM service timeout")
            
            # ä»åº”èƒ½æ¥æ”¶å’Œå­˜å‚¨æ¶ˆæ¯
            response = client.post("/api/v1/messages", json={
                "content": "éœ€è¦æ™ºèƒ½å›å¤çš„æ¶ˆæ¯",
                "type": "text",
                "session_id": "session_123"
            })
            
            assert response.status_code == 201
            
            # éªŒè¯æ¶ˆæ¯è¢«å­˜å‚¨
            message = response.json()["data"]
            assert message["content"] == "éœ€è¦æ™ºèƒ½å›å¤çš„æ¶ˆæ¯"
            
            # éªŒè¯é™çº§æç¤º
            assert "æ™ºèƒ½å›å¤æš‚æ—¶ä¸å¯ç”¨" in message.get("note", "")
```

---

## 8. ç°åº¦ä¸å›æ»šæµ‹è¯•

### 8.1 ç°åº¦å‘å¸ƒæµ‹è¯•

#### ğŸ¯ é‡‘ä¸é›€å‘å¸ƒæµ‹è¯•
```python
class TestCanaryDeployment:
    def test_canary_release_gradual_rollout(self):
        """æµ‹è¯•é‡‘ä¸é›€å‘å¸ƒé€æ­¥ä¸Šçº¿"""
        # 1. éƒ¨ç½²æ–°ç‰ˆæœ¬åˆ°10%æµé‡
        canary_config = {
            "version": "v1.1.0",
            "traffic_percentage": 10,
            "target_tenants": ["tenant_canary_1", "tenant_canary_2"]
        }
        
        deployment_result = k8s_manager.deploy_canary(canary_config)
        assert deployment_result["status"] == "success"
        
        # 2. éªŒè¯éƒ¨åˆ†ç”¨æˆ·ä½¿ç”¨æ–°ç‰ˆæœ¬
        for tenant_id in canary_config["target_tenants"]:
            instance_info = k8s_manager.get_instance_info(tenant_id)
            assert instance_info["version"] == "v1.1.0"
        
        # 3. ç›‘æ§å…³é”®æŒ‡æ ‡
        metrics = monitoring.get_canary_metrics(duration_minutes=30)
        assert metrics["error_rate"] < 0.01  # é”™è¯¯ç‡ < 1%
        assert metrics["response_time_p95"] < 200  # P95å“åº”æ—¶é—´ < 200ms
        
        # 4. å¦‚æœæŒ‡æ ‡æ­£å¸¸ï¼Œæ‰©å¤§å‘å¸ƒèŒƒå›´
        if metrics["error_rate"] < 0.005:
            expanded_config = {**canary_config, "traffic_percentage": 50}
            k8s_manager.update_canary(expanded_config)
```

### 8.2 å›æ»šæµ‹è¯•

#### âª å¿«é€Ÿå›æ»šæµ‹è¯•
```python
class TestRollback:
    def test_automatic_rollback_on_high_error_rate(self):
        """æµ‹è¯•é«˜é”™è¯¯ç‡è§¦å‘è‡ªåŠ¨å›æ»š"""
        # 1. æ¨¡æ‹Ÿæ–°ç‰ˆæœ¬å‡ºç°é«˜é”™è¯¯ç‡
        with patch('monitoring.get_error_rate') as mock_error_rate:
            mock_error_rate.return_value = 0.05  # 5%é”™è¯¯ç‡
            
            # 2. è‡ªåŠ¨å›æ»šåº”è¯¥è¢«è§¦å‘
            rollback_result = deployment_manager.check_and_rollback()
            assert rollback_result["action"] == "rollback_triggered"
            assert rollback_result["reason"] == "high_error_rate"
        
        # 3. éªŒè¯å›æ»šåˆ°ä¸Šä¸€ç¨³å®šç‰ˆæœ¬
        instances = k8s_manager.list_instances()
        for instance in instances:
            assert instance["version"] == "v1.0.0"  # å›æ»šåˆ°ç¨³å®šç‰ˆæœ¬
        
        # 4. éªŒè¯æœåŠ¡æ¢å¤æ­£å¸¸
        health_check = service_monitor.overall_health()
        assert health_check["status"] == "healthy"
```

---

## 9. æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

### 9.1 è¦†ç›–ç‡ç›®æ ‡

#### ğŸ“Š åˆ†æ¨¡å—è¦†ç›–ç‡è¦æ±‚
| æ¨¡å— | å•å…ƒæµ‹è¯•è¦†ç›–ç‡ | é›†æˆæµ‹è¯•è¦†ç›–ç‡ | æ•´ä½“è¦æ±‚ |
|------|---------------|---------------|----------|
| **è®¤è¯æˆæƒ** | > 95% | > 90% | å…³é”®å®‰å…¨æ¨¡å— |
| **ç§Ÿæˆ·ç®¡ç†** | > 90% | > 85% | æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ |
| **æ¶ˆæ¯å¤„ç†** | > 85% | > 80% | ä¸»è¦åŠŸèƒ½æ¨¡å— |
| **æ•°æ®ç»Ÿè®¡** | > 80% | > 70% | åˆ†ææŠ¥è¡¨æ¨¡å— |
| **ç³»ç»Ÿé…ç½®** | > 85% | > 75% | è¿ç»´ç®¡ç†æ¨¡å— |

### 9.2 è‡ªåŠ¨åŒ–æµ‹è¯•è¦†ç›–ç‡

#### ğŸ¤– CI/CDé›†æˆæµ‹è¯•
```yaml
# .github/workflows/test.yml
name: æµ‹è¯•æµæ°´çº¿

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: è¿è¡Œå•å…ƒæµ‹è¯•
        run: |
          pytest tests/unit/ --cov=app --cov-report=xml
          pytest tests/unit/ --cov-fail-under=80
      
      - name: ä¸Šä¼ è¦†ç›–ç‡æŠ¥å‘Š
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
  
  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
      - name: å¯åŠ¨æµ‹è¯•ç¯å¢ƒ
        run: docker-compose -f docker-compose.test.yml up -d
      
      - name: è¿è¡Œé›†æˆæµ‹è¯•
        run: pytest tests/integration/ --maxfail=5
      
      - name: è¿è¡ŒE2Eæµ‹è¯•
        run: npx playwright test
  
  performance-tests:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: è¿è¡Œæ€§èƒ½æµ‹è¯•
        run: pytest tests/performance/ --benchmark-only
```

---

## ğŸ“‹ æµ‹è¯•æ‰§è¡Œæ€»ç»“

### âœ… æµ‹è¯•æ‰§è¡Œç­–ç•¥
- **æ¯æ¬¡æäº¤**: è¿è¡Œå•å…ƒæµ‹è¯•å’Œå¿«é€Ÿé›†æˆæµ‹è¯•
- **æ¯æ—¥æ„å»º**: è¿è¡Œå®Œæ•´çš„é›†æˆæµ‹è¯•å¥—ä»¶
- **å‘å¸ƒå‰**: è¿è¡Œå…¨é‡æµ‹è¯•åŒ…æ‹¬E2Eå’Œæ€§èƒ½æµ‹è¯•
- **ç”Ÿäº§ç›‘æ§**: æŒç»­è¿è¡Œå¥åº·æ£€æŸ¥å’ŒçƒŸé›¾æµ‹è¯•

### âœ… è´¨é‡é—¨ç¦
- **ä»£ç è¦†ç›–ç‡**: å¿…é¡»è¾¾åˆ°è®¾å®šçš„æœ€ä½è¦æ±‚
- **æµ‹è¯•é€šè¿‡ç‡**: 100%çš„æµ‹è¯•å¿…é¡»é€šè¿‡
- **æ€§èƒ½æŒ‡æ ‡**: ä¸èƒ½ä½äºåŸºå‡†æ€§èƒ½
- **å®‰å…¨æ‰«æ**: ä¸èƒ½æœ‰é«˜å±å®‰å…¨é—®é¢˜

---

**æµ‹è¯•è®¡åˆ’ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2024å¹´  
**ä¸‹ä¸€æ­¥**: æµ‹è¯•ç¯å¢ƒæ­å»ºå’Œæµ‹è¯•æ•°æ®å‡†å¤‡
